#!/usr/bin/perl
#  vi: set sw=2 ai sm:
# vim: set sw=2 ai sm:

use strict;
use integer;
use utf8;

use POSIX;
use Data::Dumper;

use Getopt::Long;
use vars qw( $debug );
use vars qw( $target_time_step );
use vars qw( $ssid_scan_frequency $ssid_rescan_frequency $ssid_scan_frequency_in_moving_train );

$target_time_step = 5;
$ssid_rescan_frequency = 30;	# while wlan0 is up
$ssid_scan_frequency = 10;	# while wlan0 is down
$ssid_scan_frequency_in_moving_train = 5;

use vars qw( $ambient_light_input $brightness_input $max_brightness_input );
use vars qw( $lid_state_input );
use vars qw( $wifi_state_input_template );

$ambient_light_input  = '/sys/class/hwmon/hwmon2/device/light'; # or /sys/devices/platform/applesmc.768/light
$brightness_input     = '/sys/class/backlight/intel_backlight/brightness';
$max_brightness_input = '/sys/class/backlight/intel_backlight/max_brightness';
$lid_state_input      = '/proc/acpi/button/lid/LID0/state';
$wifi_state_input_template     = '/sys/class/net/wlan%d/operstate';

use vars qw( $battery_present_input $battery_status_input $battery_capacity_input $battery_design_capacity_input
    $battery_charge_input $battery_reserve_charge_input $battery_temperature_input $battery_voltage_input );

$battery_present_input         = '/sys/class/power_supply/BAT0/present';
$battery_status_input          = '/sys/class/power_supply/BAT0/status';
$battery_capacity_input        = '/sys/class/power_supply/BAT0/charge_full';
$battery_design_capacity_input = '/sys/class/power_supply/BAT0/charge_full_design';
$battery_charge_input          = '/sys/class/power_supply/BAT0/charge_now';
$battery_reserve_charge_input  = '/sys/class/power_supply/BAT0/alarm';
$battery_temperature_input     = '/sys/class/power_supply/BAT0/temp';
$battery_voltage_input         = '/sys/class/power_supply/BAT0/voltage_now';

use vars qw( %possibly_a_moving_train_ssids %not_a_moving_train_ssids );
%possibly_a_moving_train_ssids = (
  'GO WIFI by Cruze',	# Yorkdale
  'Free WiFi at GO',
  'TCONNECT',
);
%not_a_moving_train_ssids = (
  'eduroam',
);


use vars qw( $min_acceptable_backlight_brightness $battery_design_capacity $min_acceptable_battery_charge );

use vars qw( $last_guess_of_a_moving_train );


sub log_generic ($$;$) {
  my($flag, $msg, $debug_level) = @_;
  $msg =~ s/(\\)/\\\1/sg;
  $msg =~ s/\r/\\r/sg;
  $msg =~ s/\n/\\n/sg;
  printf STDERR "%d%s\t%s\n", time, $flag, $msg if $debug >= $debug_level;
}

sub log_comment ($;$) {
  my($s, $debug_level) = @_;
  return log_generic '#', $s, $debug_level;
}

sub log_input ($;$) {
  my($s, $debug_level) = @_;
  return log_generic '<', $s, $debug_level;
}

sub log_output ($;$) {
  my($s, $debug_level) = @_;
  return log_generic '>', $s, $debug_level;
}

sub read_string_from_file ($) {
  my($filename) = @_;
  my $it;
  local(*INPUT, $_, $.);
  if (open INPUT, '<', $filename) {
    log_comment "reading $filename", 2;
    $it = scalar <INPUT>;
    chomp $it;
    log_input $it, 2;
    close INPUT;
  }
  return $it;
}

sub read_number_from_file ($) {
    my($filename) = @_;
    my $it = read_string_from_file $filename;
    $it += 0 if defined $it;
    return $it;
}

sub get_ambient_light () {
  my $it;
  local(*INPUT, $_);
  my $s = read_string_from_file $ambient_light_input;
  $it = [$1, $2] if defined $s && $s =~ /^\((\d+),(\d+)\)/;
  return $it;
}

sub get_max_backlight_brightness () {
  return read_number_from_file $max_brightness_input;
}

sub get_backlight_brightness () {
  return read_number_from_file $brightness_input;
}

sub set_backlight_brightness ($) {
  my($brightness) = @_;
  local(*OUTPUT, $_);
  if (open(OUTPUT, '>', $brightness_input)) {
    log_comment "setting brightness to $brightness", 1;
    print OUTPUT "$brightness\n";
    close OUTPUT;
  } else {
    log_comment "$brightness_input: creat: $!";
  }
  return get_backlight_brightness;
}

sub get_lid_state () {
  my $state;
  local($`, $&, $', $1);
  my $s = read_string_from_file $lid_state_input;
  $state = $1 if $s =~ /^state:\s+(\S+)/;
  return $state;
}

sub get_battery_detected () {
  return read_number_from_file $battery_present_input;
}

sub get_battery_status () {
  return read_string_from_file $battery_status_input;
}

sub get_battery_design_capacity () {
  return read_number_from_file $battery_design_capacity_input;
}

sub get_battery_capacity () {
  return read_number_from_file $battery_capacity_input;
}

sub get_battery_charge () {
  return read_number_from_file $battery_charge_input;
}

sub get_battery_reserve_charge () {
  return read_number_from_file $battery_reserve_charge_input;
}

sub get_battery_temperature () {
  return read_number_from_file $battery_temperature_input;
}

sub get_battery_input_voltage () {
  return read_number_from_file $battery_voltage_input;
}

sub might_be_on_a_moving_train ($) {
  my($ssids) = @_;
  my $it;

use vars qw(  %not_a_moving_train_ssids );
  my $possibly_is = join(' ', map { defined $ssids->{$_}? $_: ()} sort keys %possibly_a_moving_train_ssids);
  my $possibly_not = join(' ', map { defined $ssids->{$_}? $_: ()} sort keys %not_a_moving_train_ssids);
  if ($possibly_is) {
    log_comment "possibly-a-moving-train ssid detected: $possibly_is", 3;
    $last_guess_of_a_moving_train = time;
    $it = 1;
  } elsif ($possibly_not) {
    log_comment "not-a-moving-train ssid detected: $possibly_not", 3;
    $it = 0;
    undef $last_guess_of_a_moving_train;
  } elsif (defined $last_guess_of_a_moving_train && time - $last_guess_of_a_moving_train < 600) {
    log_comment "moving train guess not expired, assuming we're still on the train", 3;
    $it = 1;
  } else {
    log_comment 'no moving train network detected', 3;
    undef $last_guess_of_a_moving_train;
  }
  return $it;
}

sub wifi_is_up () {
  my $it;
  for (my $i = 0; $i < 10; $i += 1) {
    my $input = sprintf $wifi_state_input_template, $i;
    my $s = read_string_from_file $input if -f $input;
    $it = 1 if $s eq 'up'; # or down, or dormant
  last if defined $it;
  }
  return $it;
}

sub wifi_is_down () {
  my $it;
  if (!wifi_is_up) {
    for (my $i = 0; $i < 10; $i += 1) {
      my $input = sprintf $wifi_state_input_template, $i;
      my $s = read_string_from_file $input if -f $input;
      $it = 1 if $s eq 'down'; # or up, or dormant
    last if defined $it;
    }
  }
  return $it;
}

sub scan_ssid () {
  my %ssid;
  my $cmd_name = 'iwlist';
  my $cmd_path = (map { my $det = "$_/$cmd_name"; -f $det? $det: (); } qw( /sbin /usr/sbin /bin /usr/bin ))[0];
  my @cmd = ($cmd_path, 'scan');
  local(*INPUT, $_, $1);
  my $h = open(INPUT, '-|');
  die "scan_ssid: Can't find $cmd_name\n" unless $cmd_name;
  die "scan_ssid: $cmd_name: fork: $!\n" unless defined $h;
  if ($h) {
    my $bssid;
    while (<INPUT>) {
      chomp;
      if (/^\s*Cell \S+ - Address: (\S+)/) {
	$bssid = $1;
      } elsif (/ESSID:"(.*)"\s*/) {
	$ssid{$1}->{$bssid} = 1;
      }
    }
    close INPUT;
  } else {
    POSIX::close(2); # close STDERR
    POSIX::dup(1); # dup STDOUT into STDERR
    exec { $cmd_name } @cmd;
    die "scan_ssid: $cmd_name: exec: $!\n";
  }
  return \%ssid;
}

sub probe_environment () {
  my $max_backlight_brightness = get_max_backlight_brightness;
  $min_acceptable_backlight_brightness = $max_backlight_brightness/100;
  $min_acceptable_backlight_brightness = 1 if !$min_acceptable_backlight_brightness;
  log_comment "brightness: max=$max_backlight_brightness -> min acceptable=$min_acceptable_backlight_brightness", 2;

  if (get_battery_detected) {
    my $battery_capacity = get_battery_capacity;
    $battery_design_capacity = get_battery_design_capacity;
    $min_acceptable_battery_charge = get_battery_reserve_charge;
    log_comment sprintf("battery detected, operating at %d%% design capacity", (100*$battery_capacity)/$battery_design_capacity), 1;
  } else {
    log_comment "WARNING: no battery detected!";
  }
}

sub main_loop () {
  my $t0 = time;
  my $last_acceptable_brightness;
  my($flickering, $flicker_counter);
  my($ssids, $next_ssid_scan);
  my $next_allowed_network_restart;
  for (;;) {
    my $t = time;
    my $deadline = $t + $target_time_step;
    log_comment "time=$t -> deadline=$deadline, next ssid scan=$next_ssid_scan", 3;

    my $light = get_ambient_light;
    my $lid_state = get_lid_state;
    my $backlight_brightness = get_backlight_brightness;
    log_comment sprintf("ambient light left=%d, right=%d; lid state %s; backlight brightness %d",
	$light->[0], $light->[1], $lid_state, $backlight_brightness), 1;

    if ($light->[0] || $light->[1] || $lid_state eq 'open') {
      if (!$flickering && $backlight_brightness >= $min_acceptable_backlight_brightness) {
	$last_acceptable_brightness = $backlight_brightness;
      } elsif (defined $last_acceptable_brightness) {
	log_comment "backlight $backlight_brightness too dim, restoring to last good $last_acceptable_brightness", 1;
	set_backlight_brightness $last_acceptable_brightness;
      } else {
	log_comment "backlight $backlight_brightness too dim, resetting to minimum $min_acceptable_backlight_brightness", 1;
	set_backlight_brightness $min_acceptable_backlight_brightness;
      }
      $flickering = 0;
    } elsif ($lid_state eq 'closed') {
      set_backlight_brightness $flicker_counter*(get_max_backlight_brightness/1);
      $flicker_counter = !$flicker_counter;
      $flickering = 1;
    }

    if (defined $min_acceptable_battery_charge) {
      my $battery_charge = get_battery_charge;
      if ($battery_charge < $min_acceptable_battery_charge) {
	log_comment "battery charge $battery_charge is too low (< $min_acceptable_battery_charge)";
	log_comment "attempting hibernation";
	system { 'swapon' } 'swapon', '-a';
	system { 'pm-hibernate' } 'pm-hibernate';
      }
    }

    if (time >= $next_ssid_scan) {
      if (wifi_is_up) {
	$ssids = scan_ssid;
	if ($ssids && %$ssids) {
	  log_comment('detected wifi networks: ' . join(' ', sort keys %$ssids), 2);
	  $next_ssid_scan = $t + (might_be_on_a_moving_train($ssids)? $ssid_scan_frequency_in_moving_train:
	      $ssid_rescan_frequency);
	} else {
	  log_comment('no results from wifi', 2);
	  $next_ssid_scan = $t + $ssid_scan_frequency;
	}
      } elsif (wifi_is_down) {
	$next_ssid_scan = $t + $ssid_scan_frequency;
      } elsif (time >= $next_allowed_network_restart) {
	$next_allowed_network_restart = time + 30;
	log_comment 'wifi is neither up nor down, trying to restart network-manager';
	system qw( systemctl restart network-manager );
      } else {
	log_comment 'wifi is neither up nor down, but network-manager is being restarted';
      }
    }
    if (time < $deadline) {
      my $dt = $deadline - time;
      log_comment "sleeping for $dt s", 2;
      sleep $dt;
    }
  }
}

Getopt::Long::config('bundling');
GetOptions(
  'd|debug' => sub { $debug += 1; },
) || exit(1);

$SIG{'USR1'} = sub { $debug += 1;           log_comment "SIGUSR1 received, debug level is now $debug"; };
$SIG{'USR2'} = sub { $debug -= 1 if $debug; log_comment "SIGUSR2 received, debug level is now $debug"; };

probe_environment;
main_loop;


